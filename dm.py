# calculation, callable function, or a block of logic, go in this file
# read from the constants. players and teams.
	# translate into a new collection of your choosing
from constants import PLAYERS



def x():
	while True:
		try:
			choices_var = int(input("Enter an option >\n "))
			if choices_var == 1:
				print("1) Panthers")
				print("2) Bandits")
				print("3) Warriors\n")
			if choices_var == 2:
				break
				sys.exit()
			if choices_var == 0:
				break
			else:
				continue
			while True:
				try:
					var_y = int(input("Enter an option > \n"))
					if var_y == 1:
						copy.deepcopy()
					if var_y == 2:
						copy.deepcopy()
					if var_y == 3:
						copy.deepcopy()
				except ValueError as err:
					print("Error: Enter an integer only")
		except ValueError as err:
			print("Error: Enter an integer only")

x()



def clean_panthers(PLAYERS):
	cleaned = []
	copy.deepcopy(cleaned)
	for user in PLAYERS
		fixed = {}
		fixed["feet_tall"] = user["height"].split(" ")[0]
		fixed["guardian"] = user["guardian"]
		if user["experience"] == "True":
			fixed["experience"] = True
		else:
			fixed["experience"] = False
		cleaned.append(fixed)
	return cleaned

clean_panthers(PLAYERS)
a = (clean_panthers(PLAYERS))
# [expression for temp_var in original_iterablea]

def clean_bandits():
	cleaned = []
	copy.deepcopy(cleaned)
	if user in PLAYERS:
		fixed = {}
		fixed["feet_tall"] = user["height"].split(" ")[0]
		fixed["guardian"] = user["guardian"]
		if user["experience"] == "True":
			fixed["experience"] = True
		else:
			fixed["experience"] = False
		cleaned_bandits(fixed)
	return cleaned

clean_bandits(PLAYERS)
bandits_copy = (clean_bandits(PLAYERS))
# [expression for temp_var in original_iterablea]


def clean_warriors(PLAYERS)
	cleaned = []
	copy.deepcopy(cleaned)
	for user in PLAYERS:
		fixed = {}
		fixed["feet_tall"] = user["height"].split(" ")[0]
		fixed["guardian"] = user["guardian"]
		if user["experience"] == "True":
			fixed["experience"] = True
		else:
			fixed["experience"] = False
		cleaned.append(fixed)
	return cleaned

clean_warriors(PLAYERS)
warriors_copy = (clean_warriors(PLAYERS))


def gather_players_and_teams():
	print("Bread, jelly, and peanut butter.")
	def experienced_(PLAYERS):
		cleaned = []
		copy.deepcopy(cleaned)
		copy.deepcopy(panthers_copy)
		copy.deepcopy(bandits_copy)
		copy.depcopy(warriors_copy)
		for user in PLAYERS:
			fixed ={}
			if user["experience"] == "True":
				fixed["experience"] = True
			else:
				fixed["experience"] = False
			cleaned.append(fixed)
		return cleaned

	experienced_panthers =
	experienced_bandits =
	experienced_warriors =

	experienced_(PLAYERS)

	def inexperienced_():
		cleaned = []
		for user in PLAYERS: # chante in iterable. copy.deepcopy() method
			fixed = {}



	total_inexperienced = cleaned_data
	inexperienced_panthers =
	inexperienced_bandits =
	inexperienced_warriors =

	Average height =



def combine_elements():
	print("Add peanut butter and jelly to slices and put")
	#oper = var_players / var_teams # players divided by 3 teams = 6 players per team
	#var_players = 18
	#team1_ = oper.a
	#team2_ = oper.b
	#team3_ = oper.c
	#print(oper)
	TEAMS = ["Panthers", "Bandits", "Warriors"]
	xx = len(PLAYERS)
	num_players_teams = len(PLAYERS) / len(TEAMS)
	var_v = num_players_teams
	return



def main():
	gather_players_and_teams()
	combine_elements()


# in the bottom of the script always:
# for calculation,
	# callable function
		# block of logic
if __name__ == "__main__":
	main()

